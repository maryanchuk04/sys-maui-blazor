@using System.Text.RegularExpressions
@page "/"

<h1>Hello</h1>

<div style ="height: 50vh">
    <div class="d-flex justify-content-between my-2">
        <div class="d-flex">
            <HxInputText Placeholder="Search..." @bind-Value="search" style="width: 200px" />
            <HxButton CssClass="mx-2" Color="ThemeColor.Secondary" Text="<-" @onclick="HandlePrevious" />
            <HxButton CssClass="mx-2" Color="ThemeColor.Secondary" Text="->" @onclick="HandleNext" />
        </div>

        <div>
            <HxButton Color="ThemeColor.Primary" Text="Search" @onclick="HandleClick" />
            <HxButton OnClick="HandleShowClick" Color="ThemeColor.Primary">Show modal</HxButton>
        </div>
    </div>
    <div class="h-75">
        <div contenteditable="true" class="h-100 w-100" style="min-height: 400px; overflow-y: scroll; max-height: 400px; border: 1px solid black; padding: 10px">@((MarkupString)editor)</div>
        <HxInputFile OnChange="@HandleFileChange" Label="Upload file" Accept=".txt,.doc,.docx,.custom" />
    </div>

    

    @*<HxModal @ref="myModal" Title="Modal title" Backdrop="ModalBackdrop.Static">
        <BodyTemplate>
            Modal body
        </BodyTemplate>
        <FooterTemplate>
            <HxButton Text="Close" OnClick="HandleHideClick" Color="ThemeColor.Primary" />
        </FooterTemplate>
    </HxModal>*@
</div>


@code{
    private string fileContent;
    private string search;
    private string editor;
    private HxModal myModal;
    private int currentWordIndex = -1;

    private void HandleClick()
    {
        if (!string.IsNullOrEmpty(search))
        {
            var replacedText = $"<span style='background-color: gray; color: white'>{search}</span>";
            editor = fileContent.Replace(search, replacedText);
            return;
        }

        if (!string.IsNullOrEmpty(fileContent))
            editor = fileContent;
    }

    string RedText(string word) => $"<span style='background-color: red; color: white'>{word}</span>";
    string GrayText(string word) => $"<span style='background-color: gray; color: white'>{word}</span>";



    private void HandleNext()
    {
        var grayText = GrayText(search);
        var redText = RedText(search);

        if (currentWordIndex == -1)
        {
            editor = ReplaceFirst(editor, grayText, redText);
            currentWordIndex = editor.IndexOf(redText);
            return;
        }

        editor = editor.Replace(redText, grayText);
        editor = ReplaceFirstByIndex(editor, grayText, redText, currentWordIndex + grayText.Length);
        currentWordIndex = editor.IndexOf(redText);
    }

    private void HandlePrevious()
    {
        var grayText = GrayText(search);
        var redText = RedText(search);

        if (currentWordIndex <= editor.IndexOf(redText))
        {
            currentWordIndex = editor.LastIndexOf(grayText);
            editor = editor.Replace(redText, grayText);
            editor = ReplaceFirstByIndex(editor, grayText, redText, currentWordIndex);

            currentWordIndex = editor.IndexOf(redText);
            return;
        }


        if (currentWordIndex == -1)
        {
            HandleNext();
            return;
        }

        editor = editor.Replace(redText, grayText);
        editor = ReplacePrevious(editor, grayText, redText, currentWordIndex);
        currentWordIndex = editor.IndexOf(redText);
    }

    private string ReplacePrevious(string input, string word, string replacement, int startIndex)
    {
        int index = input.LastIndexOf(word, startIndex - 1);
        if (index == -1)
        {
            return input; // слово не знайдено, повертаємо вихідний рядок
        }
        return input.Substring(0, index) + replacement + input.Substring(index + word.Length);
    }

    private string ReplaceFirstByIndex(string input, string word, string replacement, int startIndex = 0)
    {
        int index = input.IndexOf(word, startIndex);
        if (index == -1)
        {
            return input; // слово не знайдено, повертаємо вихідний рядок
        }
        return input.Substring(0, index) + replacement + input.Substring(index + word.Length);
    }

    private async Task HandleFileChange(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file != null)
        {
            using (var memoryStream = new MemoryStream())
            {
                await file.OpenReadStream().CopyToAsync(memoryStream);
                memoryStream.Position = 0;
                using (var streamReader = new StreamReader(memoryStream))
                {
                    fileContent = await streamReader.ReadToEndAsync();
                    editor = fileContent;
                }
            }
        }
    }

    private async Task HandleShowClick()
    {
        await myModal.ShowAsync();
    }

    private async Task HandleHideClick()
    {
        await myModal.HideAsync();
    }

    public string ReplaceFirst(string text, string search, string replace)
    {
        int pos = text.IndexOf(search);
        if (pos < 0)
        {
            return text;
        }
        return text.Substring(0, pos) + replace + text.Substring(pos + search.Length);
    }
    }